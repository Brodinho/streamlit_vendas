import pandas as pd
import streamlit as st
import plotly.express as px
from dataset import df
from PIL import Image
from utils import formata_colunas_monetarias, formatar_valor, formatar_moeda
from grafics import (criar_mapa_estado, criar_grafico_linha_mensal, 
                    criar_grafico_barras_estado, criar_grafico_barras_categoria)
from config import carregar_configuracoes, salvar_configuracoes

# Configura√ß√£o da p√°gina - deve ser a primeira chamada Streamlit
st.set_page_config(
    page_title="Dashboard de Vendas",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="collapsed"
)

image = Image.open('imagens/sales.png')

# Dicion√°rio de mapeamento de nomes de colunas
mapeamento_colunas = {
    'sequencial': 'Sequencial',
    'tipo': 'Tipo Movimento',
    'codtra': 'Transa√ß√£o',
    'os': 'O.S.',
    'itemOS': 'Item O.S.',
    'codcli': 'C√≥digo Cliente',
    'cnpj': 'CNPJ',
    'razao': 'Raz√£o Social',
    'fantasia': 'Fantasia',
    'cfop': 'CFOP',
    'data': 'Data Cadastro',
    'emissao': 'Data Emiss√£o',
    'nota': 'Nota N√∫mero',
    'serie': 'S√©rie',
    'chaveNfe': 'Chave NF-e',
    'item': 'Item',
    'codProduto': 'C√≥d. do Produto',
    'produto': 'Produto',
    'unidSaida': 'Unid. de Sa√≠da',
    'ncm': 'NCM',
    'codGrupo': 'C√≥d. do Grupo',
    'grupo': 'Grupo',
    'codSubGrupo': 'C√≥d. Sub-Grupo',
    'codVendedor': 'C√≥d. Vendedor',
    'vendedorRed': 'Vendedor Reduzido',
    'cidade': 'Cidade',
    'uf': 'U.F.',
    'tipoOs': 'Tipo OS',
    'descricaoTipoOs': 'Descri√ß√£o Tipo OS',
    'codRegiao': 'C√≥d. Regi√£o',
    'valorfaturado': 'Valor Faturado',
    'quant': 'Quantidade',
    'valoripi': 'Valor IPI',
    'valoricms': 'Valor ICMS',
    'valoriss': 'Valor ISS',
    'valorSubs': 'Valor Sub. Trib.',
    'valorFrete': 'Valor do Frete',
    'valorNota': 'Valor da Nota',
    'valorContabil': 'Valor Cont√°bil',
    'retVlrPis': 'Ret. Valor PIS',
    'retVlrCofins': 'Ret. Valor COFINS',
    'aliIpi': 'Al√≠quota IPI',
    'porReducaoIcms': 'Porc.Redu√ß√£o ICMS',
    'cstIcms': 'CST ICMS',
    'baseIcms': 'Base ICMS',
    'valorCusto': 'Valor Custo',
    'valorDesconto': 'Valor do Desconto',
    'desctra': 'Descri√ß√£o da Transa√ß√£o',
    'servico': 'Servi√ßo',
    'libFatura': 'Dt. Lib. Fatura',
    'latitude': 'Latitude',
    'longitude': 'Longitude'
}

def formatar_numero_br(numero):
    """Formata um n√∫mero para o padr√£o brasileiro (ex: 1.234,56)"""
    return f"{numero:,}".replace(",", "X").replace(".", ",").replace("X", ".")

def formata_colunas_monetarias(valor):
    """Formata valores monet√°rios para o padr√£o brasileiro"""
    if pd.isna(valor):
        return ""
    return f"R$ {valor:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")

def formatar_data(data):
    """Formata data para o padr√£o brasileiro"""
    if pd.isna(data):
        return ""
    return data.strftime('%d-%m-%Y')

def formatar_datetime(data):
    """Formata datetime para o padr√£o brasileiro"""
    if pd.isna(data):
        return ""
    return data.strftime('%d-%m-%Y %H:%M:%S')

def mostrar_configuracao():
    st.title('Configura√ß√£o do Dashboard')
    st.write('Selecione os gr√°ficos que deseja visualizar:')

    # Lista completa de gr√°ficos dispon√≠veis
    graficos = {
        'mapa': 'Mapa de Faturamento por Estado/Pa√≠s',
        'barras_estado': 'Gr√°fico de Barras - Top 5 Estados/Pa√≠ses',
        'linha_mensal': 'Gr√°fico de Linha - Faturamento Mensal',
        'barras_categoria': 'Gr√°fico de Barras - Faturamento por Categoria'
    }

    # Carregar configura√ß√µes salvas (se existirem)
    config_salva = carregar_configuracoes()
    
    # Criar checkboxes para cada gr√°fico
    selecao_graficos = {}
    for key, descricao in graficos.items():
        # Use a configura√ß√£o salva se existir, caso contr√°rio use True como padr√£o
        valor_padrao = config_salva.get(key, True) if config_salva else True
        selecao_graficos[key] = st.checkbox(descricao, value=valor_padrao)

    # Bot√£o para salvar configura√ß√µes
    if st.button('Salvar Configura√ß√µes e Visualizar Dashboard'):
        salvar_configuracoes(selecao_graficos)
        st.session_state.pagina = 'dashboard'
        st.rerun()

def mostrar_dashboard():
    # Adicionar CSS e JavaScript para traduzir textos padr√£o
    st.markdown("""
        <style>
        /* Estilos anteriores mantidos */
        [data-testid="stNumberInput"] {
            width: 150px !important;
        }
        [data-testid="stNumberInput"] > div {
            width: 150px !important;
        }
        [data-testid="stNumberInput"] input {
            width: 150px !important;
            text-align: center;
        }
        
        /* Ocultar texto em ingl√™s */
        .stTextInput > div[data-baseweb="input"] > div::after {
            display: none !important;
        }
        </style>
        
        <script>
        // Fun√ß√£o para traduzir textos
        const traducoes = {
            'Press Enter to apply': 'Pressione Enter para aplicar',
            'No results': 'Sem resultados'
        };
        
        function traduzirTextos() {
            // Traduzir todos os elementos que cont√™m os textos espec√≠ficos
            document.querySelectorAll('*').forEach(element => {
                if (element.textContent in traducoes) {
                    element.textContent = traducoes[element.textContent];
                }
            });
        }
        
        // Executar tradu√ß√£o inicial e configurar observador para mudan√ßas
        document.addEventListener('DOMContentLoaded', () => {
            traduzirTextos();
            const observer = new MutationObserver(traduzirTextos);
            observer.observe(document.body, { 
                childList: true, 
                subtree: true 
            });
        });
        </script>
    """, unsafe_allow_html=True)

    # Bot√£o para voltar √† configura√ß√£o
    if st.button('‚öôÔ∏è Configurar Gr√°ficos'):
        st.session_state.pagina = 'config'
        st.rerun()

    # Dividir o layout em duas colunas
    col1, col2 = st.columns([1, 6])
    with col1:
        st.image(image, use_container_width=True)
    with col2:
        st.title("Dashboard de Vendas")
        st.subheader("E m p r e s a m i x")

    # Criar abas
    tab1, tab2, tab3 = st.tabs(["üìä Gr√°ficos", "üìã Dataset", "üë• Vendedores"])

    with tab1:  # Aba de Gr√°ficos
        # Adicionar seletor de ano com m√∫ltipla sele√ß√£o e largura controlada
        anos_disponiveis = sorted(df['data'].dt.year.dropna().unique().astype(int))
        if anos_disponiveis:
            # CSS para controlar a largura din√¢mica mantendo altura fixa
            st.markdown(
                """
                <style>
                /* Container principal do multiselect */
                div[data-testid="stMultiSelect"] {
                    min-width: 150px;
                    width: auto !important;
                    display: inline-block !important;
                }
                
                /* Container dos itens selecionados */
                div[data-testid="stMultiSelect"] > div {
                    width: auto !important;
                    min-width: 150px;
                    display: inline-flex !important;
                }
                
                /* Container que mostra os itens selecionados */
                div[data-testid="stMultiSelect"] > div > div {
                    height: 38px !important;
                    display: inline-flex !important;
                    flex-direction: row !important;
                    flex-wrap: nowrap !important;
                    gap: 4px;
                    overflow: visible !important;
                    width: auto !important;
                }
                
                /* Estilo para os bot√µes individuais */
                div[data-testid="stMultiSelect"] div[role="button"] {
                    white-space: nowrap;
                    display: inline-block !important;
                }

                /* Container da coluna */
                div.stColumn {
                    width: auto !important;
                    min-width: 150px !important;
                    flex-grow: 1 !important;
                }
                </style>
                """, 
                unsafe_allow_html=True
            )
            
            # Criar uma coluna que se ajusta ao conte√∫do
            col1, col2 = st.columns([3, 3])  # Propor√ß√£o mais equilibrada
            with col1:
                # Adicionar op√ß√£o "Todos" e permitir m√∫ltipla sele√ß√£o
                opcoes_anos = ['Todos'] + [str(ano) for ano in anos_disponiveis]
                anos_selecionados = st.multiselect(
                    'Selecione o(s) Ano(s):', 
                    opcoes_anos,
                    default=['Todos']
                )
            
            # L√≥gica para tratar a sele√ß√£o
            if 'Todos' in anos_selecionados:
                anos_filtro = anos_disponiveis
            else:
                anos_filtro = [int(ano) for ano in anos_selecionados]
                
            if not anos_selecionados:  # Se nenhum ano selecionado
                st.warning('Por favor, selecione pelo menos um ano.')
                return
        else:
            st.error('N√£o h√° dados com datas v√°lidas dispon√≠veis')
            return

        config = carregar_configuracoes()
        
        if config is None:
            st.error('Erro ao carregar configura√ß√µes')
            st.session_state.pagina = 'config'
            st.rerun()

        if config.get('mapa', True):
            st.subheader('Mapa de Faturamento por Estado e Pa√≠ses')
            graf_map_estado = criar_mapa_estado(df, anos_filtro)
            if graf_map_estado is not None:
                st.plotly_chart(graf_map_estado, use_container_width=True)
            else:
                st.warning(f'N√£o h√° dados dispon√≠veis para o(s) ano(s) selecionado(s)')

        if config.get('barras_estado', True):
            st.subheader('Estados e Pa√≠ses com maior faturamento (Top 5)')
            grafbar_fat_estado = criar_grafico_barras_estado(df, anos_filtro)
            if grafbar_fat_estado is not None:
                st.plotly_chart(grafbar_fat_estado, use_container_width=True)
            else:
                st.warning(f'N√£o h√° dados dispon√≠veis para o(s) ano(s) selecionado(s)')

        if config.get('linha_mensal', True):
            st.subheader('Faturamento anual m√™s-a-m√™s')
            graflinha_fat_mensal = criar_grafico_linha_mensal(df, anos_filtro)
            if graflinha_fat_mensal is not None:
                st.plotly_chart(graflinha_fat_mensal, use_container_width=True)
            else:
                st.warning('N√£o h√° dados dispon√≠veis para o gr√°fico de linha mensal')

        if config.get('barras_categoria', True):
            st.subheader('Faturamento por Sub-Categoria (Top 5)')
            graf_fat_categoria = criar_grafico_barras_categoria(df, anos_filtro)
            if graf_fat_categoria is not None:
                st.plotly_chart(graf_fat_categoria, use_container_width=True)
            else:
                st.warning('N√£o h√° dados dispon√≠veis para o gr√°fico de categorias')

    with tab2:  # Aba do Dataset
        st.header("Dataset")
        
        # Inicializar df_filtrado com o DataFrame original
        df_filtrado = df.copy()
        
        # Mover filtros para a sidebar
        with st.sidebar:
            st.header("Filtros")
            
            # Obter todas as colunas dispon√≠veis com os novos nomes
            todas_colunas = [mapeamento_colunas.get(col, col) for col in df.columns]
            
            # Inicializar o estado da sess√£o se necess√°rio
            if 'colunas_selecionadas' not in st.session_state:
                st.session_state.colunas_selecionadas = todas_colunas
            
            # Criar um multiselect para sele√ß√£o de colunas
            colunas_selecionadas = st.multiselect(
                'Selecione as colunas:',
                todas_colunas,
                default=st.session_state.colunas_selecionadas
            )
            
            # Criar colunas para os bot√µes de sele√ß√£o de colunas
            btn_col1, btn_col2 = st.columns(2)
            with btn_col1:
                if st.button('Selecionar Todas'):
                    st.session_state.colunas_selecionadas = todas_colunas
                    st.rerun()
            
            with btn_col2:
                if st.button('Limpar Sele√ß√£o'):
                    st.session_state.colunas_selecionadas = []
                    st.rerun()
            
            # Adicionar campo de busca
            texto_busca = st.text_input('Buscar em todas as colunas:', '')
            
            # Adicionar CSS para controlar a largura dos dropdowns
            st.markdown("""
                <style>
                /* Container principal do selectbox */
                div[data-testid="stSelectbox"] {
                    min-width: 150px;
                    width: auto !important;
                }
                
                /* Container do selectbox em si */
                div[data-testid="stSelectbox"] > div {
                    min-width: 150px;
                    width: auto !important;
                }
                </style>
            """, unsafe_allow_html=True)
            
            # Filtros de ano e m√™s em colunas mais compactas
            col_filtro1, col_filtro2 = st.columns([1, 1])
            
            with col_filtro1:
                # Obter anos √∫nicos da coluna Data Emiss√£o
                anos_disponiveis = sorted(df_filtrado['emissao'].dt.year.dropna().unique())
                if anos_disponiveis:
                    ano_selecionado = st.selectbox(
                        'Ano:',
                        ['Todos'] + [str(ano) for ano in anos_disponiveis],
                        key='ano_filtro'
                    )
            
            with col_filtro2:
                # Lista de meses em portugu√™s
                meses = ['Todos', 'Janeiro', 'Fevereiro', 'Mar√ßo', 'Abril', 'Maio', 'Junho',
                        'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro']
                mes_selecionado = st.selectbox('M√™s:', meses, key='mes_filtro')
            
            # Adicionar expander para filtros avan√ßados
            with st.expander("üîç Filtros Avan√ßados"):
                # Identificar tipos de colunas
                colunas_numericas = []
                colunas_data = []
                colunas_texto = []
                
                for col_original, col_nova in mapeamento_colunas.items():
                    if col_nova not in colunas_selecionadas:
                        continue
                        
                    if pd.api.types.is_numeric_dtype(df[col_original]):
                        colunas_numericas.append((col_original, col_nova))
                    elif pd.api.types.is_datetime64_any_dtype(df[col_original]):
                        colunas_data.append((col_original, col_nova))
                    else:
                        colunas_texto.append((col_original, col_nova))
                
                # Criar filtros para colunas num√©ricas
                if colunas_numericas:
                    st.subheader("Filtros Num√©ricos")
                    for col_original, col_nova in colunas_numericas:
                        min_val = float(df[col_original].min())
                        max_val = float(df[col_original].max())
                        
                        # Se min e max forem iguais, ajustar para criar um range v√°lido
                        if min_val == max_val:
                            if min_val == 0:
                                max_val = float(1)  # Converter para float
                            else:
                                # Criar um pequeno range em torno do valor
                                delta = abs(min_val * 0.1)  # 10% do valor
                                min_val = float(min_val - delta)  # Converter para float
                                max_val = float(max_val + delta)  # Converter para float
                        
                        # Criar slider para cada coluna num√©rica
                        valores = st.slider(
                            f"Filtrar {col_nova}:",
                            min_value=float(min_val),  # Garantir que √© float
                            max_value=float(max_val),  # Garantir que √© float
                            value=(float(min_val), float(max_val)),  # Garantir que ambos s√£o float
                            key=f"slider_{col_original}"
                        )
                        
                        # Aplicar filtro
                        df_filtrado = df_filtrado[
                            (df_filtrado[col_original] >= valores[0]) & 
                            (df_filtrado[col_original] <= valores[1])
                        ]
                
                # Criar filtros para colunas de data
                if colunas_data:
                    st.subheader("Filtros de Data")
                    for col_original, col_nova in colunas_data:
                        # Remover valores NaT antes de pegar min e max
                        datas_validas = df[col_original].dropna()
                        if len(datas_validas) > 0:
                            min_date = datas_validas.min()
                            max_date = datas_validas.max()
                            
                            # Criar seletor de intervalo de datas
                            datas = st.date_input(
                                f"Filtrar {col_nova}:",
                                value=(min_date, max_date),
                                min_value=min_date,
                                max_value=max_date,
                                key=f"date_{col_original}"
                            )
                            
                            if len(datas) == 2:
                                data_inicio, data_fim = datas
                                df_filtrado = df_filtrado[
                                    (df_filtrado[col_original].dt.date >= data_inicio) & 
                                    (df_filtrado[col_original].dt.date <= data_fim)
                                ]
                        else:
                            st.warning(f'N√£o h√° datas v√°lidas na coluna {col_nova}')
                
                # Criar filtros para colunas de texto
                if colunas_texto:
                    st.subheader("Filtros de Texto")
                    for col_original, col_nova in colunas_texto:
                        # Obter valores √∫nicos
                        valores_unicos = df[col_original].dropna().unique()
                        if len(valores_unicos) <= 50:  # Limitar para colunas com poucos valores √∫nicos
                            valores_selecionados = st.multiselect(
                                f"Filtrar {col_nova}:",
                                options=sorted(valores_unicos),
                                key=f"multi_{col_original}"
                            )
                            
                            if valores_selecionados:
                                df_filtrado = df_filtrado[
                                    df_filtrado[col_original].isin(valores_selecionados)
                                ]
        
        # Aplicar filtros de ano e m√™s
        if ano_selecionado != 'Todos':
            df_filtrado = df_filtrado[df_filtrado['emissao'].dt.year == int(ano_selecionado)]
        
        if mes_selecionado != 'Todos':
            mes_numero = meses.index(mes_selecionado)
            df_filtrado = df_filtrado[df_filtrado['emissao'].dt.month == mes_numero]
        
        # Aplicar filtro de busca
        if texto_busca:
            mascara = pd.DataFrame(False, index=df_filtrado.index, columns=['match'])
            for coluna in df_filtrado.columns:
                mascara['match'] |= df_filtrado[coluna].astype(str).str.contains(texto_busca, case=False, na=False)
            df_filtrado = df_filtrado[mascara['match']]
        
        # Mostrar total de registros ap√≥s filtro
        total_filtrado = len(df_filtrado)
        total_original = len(df)
        
        # Criar uma nova linha para o slider de registros por p√°gina
        st.write("")  # Adiciona um espa√ßo
        col_slider1, col_slider2 = st.columns([2, 4])
        
        with col_slider1:
            # Adicionar n√∫mero de registros por p√°gina
            registros_por_pagina = st.select_slider(
                'Registros por p√°gina:',
                options=[10, 20, 30, 40, 50, 60, 70, 80, 90, 100],
                value=10,  # Valor inicial deve estar na lista de options
                key='registros_por_pagina'
            )
        
        # Mostrar o DataFrame com as colunas selecionadas
        if colunas_selecionadas:
            # Converter nomes das colunas selecionadas de volta para os nomes originais
            colunas_originais = [col for col, novo_nome in mapeamento_colunas.items() 
                               if novo_nome in colunas_selecionadas]
            
            # Reorganizar colunas (Descri√ß√£o da Transa√ß√£o ap√≥s Transa√ß√£o)
            if 'codtra' in colunas_originais and 'desctra' in colunas_originais:
                idx_codtra = colunas_originais.index('codtra')
                colunas_originais.remove('desctra')
                colunas_originais.insert(idx_codtra + 1, 'desctra')
            
            df_exibir = df_filtrado[colunas_originais].copy()
            
            # Aplicar formata√ß√µes
            for coluna in df_exibir.columns:
                # Colunas sem formata√ß√£o (n√∫meros inteiros)
                if coluna in ['sequencial', 'os', 'codGrupo', 'codVendedor', 'codcli', 'nota']:
                    df_exibir[coluna] = df_exibir[coluna].fillna('').astype(str).replace('\.0$', '', regex=True)
                    # Remove formata√ß√£o e converte para string, removendo o .0 dos n√∫meros
                
                # Colunas de data (sem hora)
                elif coluna in ['data', 'emissao']:
                    df_exibir[coluna] = pd.to_datetime(df_exibir[coluna]).dt.strftime('%d-%m-%Y')
                
                # Colunas de datetime (com hora)
                elif coluna in ['libFatura']:
                    df_exibir[coluna] = pd.to_datetime(df_exibir[coluna]).dt.strftime('%d-%m-%Y %H:%M:%S')
                
                # Colunas monet√°rias
                elif coluna in ['valorfaturado', 'valoripi', 'valoricms', 'valoriss', 
                              'valorSubs', 'valorFrete', 'valorNota', 'valorContabil',
                              'retVlrPis', 'retVlrCofins', 'baseIcms', 'valorCusto',
                              'valorDesconto']:
                    df_exibir[coluna] = df_exibir[coluna].apply(lambda x: 
                        f"R$ {x:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".") 
                        if pd.notnull(x) else "")
            
            # Renomear colunas para exibi√ß√£o
            df_exibir.columns = [mapeamento_colunas.get(col, col) for col in df_exibir.columns]
            
            # Calcular n√∫mero de p√°ginas
            num_paginas = max(1, (total_filtrado + registros_por_pagina - 1) // registros_por_pagina)
            
            # Criar uma coluna estreita para o input de p√°gina
            col_pagina1, col_pagina2 = st.columns([1, 15])
            with col_pagina1:
                pagina_atual = st.number_input(
                    'P√°gina:', 
                    min_value=1, 
                    max_value=num_paginas, 
                    value=min(1, num_paginas)
                ) - 1
            
            inicio = pagina_atual * registros_por_pagina
            fim = min(inicio + registros_por_pagina, total_filtrado)
            
            # Mostrar informa√ß√µes de pagina√ß√£o
            if total_filtrado > 0:
                st.write(f"Mostrando {formatar_numero_br(inicio+1)} a {formatar_numero_br(fim)} de {formatar_numero_br(total_filtrado)} registros | Total de p√°ginas: {formatar_numero_br(num_paginas)}")
            else:
                st.write("Nenhum registro encontrado")
            
            # Aplicar pagina√ß√£o ao DataFrame
            df_pagina = df_exibir.iloc[inicio:fim]
            st.dataframe(df_pagina)
        else:
            st.warning('Por favor, selecione pelo menos uma coluna para visualizar os dados.')

    with tab3:  # Aba de Vendedores
        st.header("Vendedores")
        # Adicione aqui o c√≥digo para exibir informa√ß√µes dos vendedores
        vendedores = df[['vendedor', 'valorNota']].groupby('vendedor').sum().sort_values('valorNota', ascending=False)
        st.dataframe(vendedores)

    # Adicionar CSS para tradu√ß√£o
    st.markdown("""
        <style>
        /* Tradu√ß√£o via CSS usando pseudo-elementos */
        div[data-baseweb="input"] div[data-testid="stTextInput"]::after {
            content: "Pressione Enter para aplicar" !important;
        }
        
        div[role="listbox"] div[role="option"][aria-selected="false"]:empty::after {
            content: "Sem resultados" !important;
        }
        
        /* Controle de largura dos inputs */
        [data-testid="stNumberInput"] {
            width: 150px !important;
        }
        [data-testid="stNumberInput"] > div {
            width: 150px !important;
        }
        [data-testid="stNumberInput"] input {
            width: 150px !important;
            text-align: center;
        }
        </style>
    """, unsafe_allow_html=True)

def main():
    # Inicializar o estado da sess√£o se necess√°rio
    if 'pagina' not in st.session_state:
        st.session_state.pagina = 'config'

    # Mostrar a p√°gina apropriada
    if st.session_state.pagina == 'config':
        mostrar_configuracao()
    else:
        mostrar_dashboard()

if __name__ == '__main__':
    main()

